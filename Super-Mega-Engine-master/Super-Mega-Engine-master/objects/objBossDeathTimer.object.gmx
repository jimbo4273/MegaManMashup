<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>mskMegaman</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Handles the boss's death
//Also transforms into the Mega Man that automatically moves to the center of the screen

bossID = instance_nearest(x, y, prtBoss).bossID;

//If there is a teleporter in the room (boss rush), just destroy the death timer
instance_activate_object(objTeleport);
with objTeleport {
    if insideView() {
        on = true;
        var inst = instance_create(other.x, other.y, objLifeEnergyBig);
        inst.alarm[0] = room_speed * 9999;
        global.bossRushDefeated[other.bossID] = true;
        if numRushBossesDefeated() == 8 {
            instance_activate_object(objBossDoor);
            objBossDoor.canOpen = true;
        }
        with other instance_destroy();
        with objBossControl {
            drawHealthBar = false;
        }
        exit;
    }
}

//Otherwise, normal behavior (weapon absorb, etc...)
alarm[0] = 240;

xspeed = 0;
yspeed = 0;
isMM = false;
ground = true;
prevGround = ground;
canInitJump = true;
absorbing = false;
absorbAmount = 0;
startTeleportTimer = 0;
teleporting = false;
teleportTimer = 0;
teleportY = 0;
update_rate = 1;

with prtPlayer canPause = false;
with prtPlayerProjectile instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Go to next room

var ID = instance_create(x, y, objFadeout);
ID.type = "room";
    
if global.weaponID &gt; -1 &amp;&amp; !global.weaponID.unlocked {
    ID.myRoom = rmWeaponGet;
    global.passPlayVictory = false;
}
else if !global.fortressStarted {
    ID.myRoom = rmPass;
    global.passPlayVictory = true;
}
else if global.fortressLevels[global.currentFortressLevel] == room {
    global.fortressLevelDone[global.currentFortressLevel] = true;
    global.currentFortressLevel++;
    if global.currentFortressLevel &gt;= global.numFortressLevels {
        //Ending
        ID.myRoom = rmCredits;
    }
    else {
        ID.myRoom = rmFortress;
    }
}

global.passContinueRoom = room;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize fake Mega Man movement

x = prtPlayer.x;
y = prtPlayer.y;
sprite_index = prtPlayer.spriteWalk;
image_speed = 0.15;
isMM = true;

with prtPlayer visible = false;
with prtPlayerProjectile instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Lock movement and play music

playerLockMovement();

if global.fortressStarted &amp;&amp; global.fortressLevels[global.currentFortressLevel] == room &amp;&amp;
global.currentFortressLevel &gt;= global.numFortressLevels - 1 {
    playMusicNoLoop(bgmBeatFinalBoss);
}
else {
    playMusicNoLoop(bgmVictory);
}
with prtPlayer event_user(0); //Resets the colors, so charging the buster won't affect the colors

alarm[1] = 270;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if isMM {
    with prtPlayerProjectile instance_destroy();
}
if isMM == true &amp;&amp; teleporting == false
{
    if absorbing == false
    {
        var destX;
        destX = round(view_xview[0] + (view_wview[0]/2));
        
        checkGround();
        gravityCheckGround();
        generalCollision();
        
        if x &lt; destX-2 || x &gt; destX+2
        {
            if x &lt; destX
            {
                xspeed = cfgWalkSpeed;
                image_xscale = 1;
            }
            else if x &gt; destX
            {
                xspeed = -cfgWalkSpeed;
                image_xscale = -1;
            }
            
            if (place_meeting(x+xspeed*8, y, objSolid) || place_meeting(x+xspeed*8, y, prtMovingPlatformSolid))
            &amp;&amp; ground == true
            {
                if ((position_meeting(bbox_right+xspeed*8, bbox_top, objSolid) || position_meeting(bbox_right+xspeed*8, bbox_top, prtMovingPlatformSolid))
                &amp;&amp; image_xscale == 1)
                || ((position_meeting(bbox_left+xspeed*8, bbox_top, objSolid) || position_meeting(bbox_left+xspeed*8, bbox_top, prtMovingPlatformSolid))
                &amp;&amp; image_xscale == -1) //If we are blocked by a wall of at least 2 blocks high, perform a high jump
                    yspeed = -5.25;
                else //Else, perform a short, 1-block-high jump
                    yspeed = -3.5;
            }
            
            if ground == true
                sprite_index = prtPlayer.spriteWalk;
            else
                sprite_index = prtPlayer.spriteJump;
                
                
            if prevGround == false &amp;&amp; ground == true
                playSFX(sfxLand);
                
            prevGround = ground;
        }
        else
        {
            if canInitJump == true &amp;&amp; ground == true
            {
                if global.weaponID &gt; -1 &amp;&amp; !global.weaponID.unlocked //Only absorb the power if it's not already been unlocked
                {
                    canInitJump = false;
                    
                    x = destX;
                    sprite_index = prtPlayer.spriteJump;
                    yspeed = -8;
                    xspeed = 0;
                }
                else
                {
                    //Teleport out
                    yspeed = 0;
                    teleporting = true;
                    alarm[2] = 60;
                    playSFX(sfxTeleportOut);
                    sprite_index = prtPlayer.spriteTeleport;
                }
            }
            
            if yspeed &gt; 0 &amp;&amp; y &gt;= view_yview[0]+112 &amp;&amp; canInitJump == false &amp;&amp; !global.weaponID.unlocked
            {
                y = view_yview[0]+112;
                absorbing = true;
            }
        }
        
        
        x += xspeed;
        y += yspeed;
    }
    else
    {
        //Absorbing the boss's power
        if !instance_exists(objAbsorbEffect)
        {
            if absorbAmount &lt; 3
            {
                absorbAmount += 1;
                
                playSFX(sfxAbsorb);
                var ID, fastSpd, slowSpd, radius, angle;
                fastSpd = 7;
                slowSpd = 3;radius = view_wview[0]/2;
                angle = 0;
                
                repeat 8
                {
                    angle += 0.25*pi;
                    
                    ID = instance_create(sprite_get_xcenter() + radius*cos(angle), sprite_get_ycenter() + radius*sin(angle), objAbsorbEffect);
                        ID.spd = fastSpd;
                    ID = instance_create(sprite_get_xcenter() + radius*cos(angle), sprite_get_ycenter() + radius*sin(angle), objAbsorbEffect);
                        ID.spd = slowSpd; 
                }
            }
            else
            {
                checkGround();
                gravityCheckGround();
                generalCollision();
                
                if ground == true
                {
                    sprite_index = prtPlayer.spriteStand;
                    image_speed = 0;
                    image_index = 0;
                    
                    startTeleportTimer += 1;
                    if startTeleportTimer &gt;= 55
                    {
                        startTeleportTimer = 0;
                        yspeed = 0;
                        teleporting = true;
                        alarm[2] = 60;
                        playSFX(sfxTeleportOut);
                        sprite_index = prtPlayer.spriteTeleport;
                    }
                }
                
                y += yspeed;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if isMM == true
{
    if teleporting == false
    {
        drawPlayer();
    }
    else
    {
        if teleportY == 0
        {
            if teleportTimer == 2
                image_index = 2;
            else if teleportTimer == 4
                image_index = 0;
            else if teleportTimer == 6
                image_index = 1;
            else if teleportTimer = 9
            {
                teleportY -= 7;
                image_speed = 0;
                image_index = 0;
                exit;
            }
            
            if global.frozen == false
                teleportTimer += 1;
        }
        else
        {
            //Teleporting upwards            
            if global.frozen == false
                teleportY -= 7;
        }
        
        drawSpriteColorSwap(prtPlayer.spriteTeleport, image_index, round(x), round(y+teleportY), global.charPrimaryColor, global.charSecondaryColor, make_colour_rgb(1.0, 1.0, 1.0),global.primaryCol,global.secondaryCol, global.outlineCol);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
