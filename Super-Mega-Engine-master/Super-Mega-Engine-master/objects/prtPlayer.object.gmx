<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMegamanStand</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>mskMegaman</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if object_index == prtPlayer {
    instance_create(x, y, global.character);
    instance_destroy();
    exit;
}

name = "";
sprName = "";

if room != rmInit {
    //Teleport to the checkpoint location, if we hit a checkpoint
    if global.checkpoint {
        x = global.checkpointX;
        y = global.checkpointY;
    }
    
    placeTileObjects();
    placeTileAnimations();
    placeRoomBorders();
    placeHorizontalBorders();
    mergeBlocks();

    //Initialize the camera
    newSectionXOffset = 0;
    newSectionYOffset = 0;
    playerCameraInit();
}


//Physics variables
grav = cfgGravity; //The player's gravity
gravWater = cfgGravityWater; //The player's gravity in water
jumpSpeed = cfgJumpSpeed;  //Dunno why grav needs to be multiplied by 2, but MM jumps as high as in MM5 when doing so
jumpSpeedWater = cfgJumpSpeedWater;
walkSpeed = cfgWalkSpeed;
maxVspeed = cfgMaxFallingSpeed;
stepSpeed = cfgStepSpeed;
stepFrames = cfgStepFrames;
iceDec = cfgIceDec; //The deceleration on ice when not holding any buttons
iceDecWalk = cfgIceDecWalk; //The deceleration on ice when moving in the opposite direction
slideSpeed = cfgSlideSpeed;
slideFrames = cfgSlideFrames;
climbSpeed = cfgClimbSpeed; //Official value of MM3
initChargeTime = cfgInitChargeTime; //The amount of frames after which to start charging after the shooting animation is complete
chargeTime = cfgChargeTime; //Official value of MM6
hitTime = cfgHitTime; //The amount of frames you experience knockback after getting hit
knockbackAmount = cfgKnockback;

enableSlide = cfgEnableSlide;
enableCharge = cfgEnableCharge;

//Variables
ground = false;
prevGround = false;
prevXScale = image_xscale;
isStep = false;
stepTimer = 0;
canInitStep = true; //Can we initialize sidestepping?
global.xspeed = 0;
global.yspeed = 0;
canMinJump = true;
canMove = true;
canSpriteChange = true;
canShoot = true;
isShoot = false;
isThrow = false;
shootTimer = 0;
isSlide = false;
slideTimer = 0;
canHit = true;
isHit = false;
hitTimer = 0;
drawHitspark = false;
invincibilityTimer = 0;
isCharge = false;
chargeTimer = 0;
initChargeTimer = 0; //The timer for when to start charging after exiting the shooting animation
canGravity = true;
climbing = false;
climbSpriteTimer = 0;
canStep = false; //We can actually perform the step event even if canStep = false; it's merely used to block certain events from happening at the first frame, as canStep becomes true after 1 frame
alarm[0] = 1; //For canStep
pharaohShotInitTimer = 0;
teleporting = false;
teleportY = 0;
teleportTimer = 0;
deathByPit = false; //Did we die by falling in a bottomless pit?
playLandSound = true; //Should we play the landing SFX when colliding with a floor? (Disabled on ladders, for example)
playLandSoundTimer = 2; //Lasts two frames, since it takes 1 extra frame for the collision code to register
currentGrav = grav; //Normal gravity or water gravity?
currentJumpSpeed = jumpSpeed; //Normal jump speed or water jump speed?
inWater = false;
bubbleTimer = 0; //Timer for the air bubble MM creates under water
blinkTimer = 0; //Timer for MM's blinking animation when standing still
blinkTimerMax = 120;
blinkImage = 0; //0 for no blinking, 1 for blinking
blinkDuration = 8; //The amount of frames the blinking lasts
drawWeaponIcon = false; //Whether or not we should draw the weapon icon above our head (used when using quick weapon switching)
drawWeaponIconTimer = -1;
onRushJet = false; //Are we on the Rush Jet?
damageMultiplier = 1;   //Multiplies damage taken
update_rate = 1;

//Reflection
reflectProjectiles = false;
reflectProjectilesRight = false; //Only reflect projectiles that come from the right
reflectProjectilesLeft = false; //Only reflect projectiles that come from the left


shoot_height = 4;
shoot_shift = 6;
jump_shoot_height = 3;


primary_color = make_colour_rgb(0, 112, 236);
secondary_color = make_colour_rgb(0, 232, 216);
src_col1 = make_colour_rgb(0, 89, 255);
src_col2 = make_colour_rgb(0, 0, 187);
src_col3 = make_colour_rgb(0, 217, 255);

global.outlineCol = c_black;

spriteStand = noone;
spriteStep = noone;
spriteWalk = noone;
spriteJump = noone;
spriteClimb = noone;
spriteGetup = noone;
    
//Static sprites
spriteSlide = noone;
spriteHit = noone;
spriteTeleport = noone;

spriteLife = sprLife;
spriteStageSelect = sprMMStageSelect;
stageSelectFollow = true;

//Show the READY text
showReady = true;
readyTimer = 0;
canSpriteChange = false;
canMove = false;
canGravity = false;
canPause = false;
image_speed = 0;

prevx = noone;

global.charTotalWeapons = 0;
var weapon_index = 0;
for (var i = 0; object_exists(i); i++) {
    if object_get_parent(i) == prtWeapon or object_get_parent(object_get_parent(i)) == prtWeapon {
        if i.character == -1 or i.character == self.object_index {
            with i {
                other.weapons[weapon_index] = self;
                other.weapons[weapon_index].newID = weapon_index;
            }
            weapon_index++;
        }
    }
}
global.charTotalWeapons = array_length_1d(weapons);
global.char_weapons_per_col = ceil(global.charTotalWeapons / 2);
global.weapons = weapons;
global.totalWeapons = global.charTotalWeapons;
global.weapons_per_col = global.char_weapons_per_col;

defaultWeapon = weapons[0];

global.charTotalEquips = 0;
var equip_index = 0;
for (var i = 0; object_exists(i); i++) {
    if (object_get_parent(i) == prtEquip or object_get_parent(object_get_parent(i)) == prtEquip) and i != prtPlateEquip {
        if ds_list_find_index(i.exceptCharacters, object_index) == -1 {
            with i {
                other.items[equip_index] = self;
                event_user(5);
            }
            //print("adding", object_get_name(i), "to index", equip_index);
            equip_index++;
        }
    }
}
global.charTotalEquips = array_length_1d(items);
global.char_equips_per_row = ceil(global.charTotalEquips / 2);
global.items = items;


if room != rmInit {
    //Set the correct whitemask colors
    event_user(0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize switching sections for doors

if newSectionXOffset &gt; 0 //Switching to the right
{
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher) 
    {
        dir = "right";
        door = true;
    }
}
else if newSectionXOffset &lt; 0 //Switching to the left
{
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher)
    {
        dir = "left";
        door = true;
    }
}
else if newSectionYOffset &gt; 0 //Switching to the bottom
{
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher) 
    {
        dir = "down";
        door = true;
    }
}
else if newSectionYOffset &lt; 0 //Switching to the top
{
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher)
    {
        dir = "up";
        door = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize switching sections


var plt = instance_place(x, y+1, prtMovingPlatformSolid);   //Moving platform below Mega Man?
if plt &gt; -1 &amp;&amp; !plt.keepOnSwitch {
    plt = -1;
}

if newSectionXOffset &gt; 0 //Switching to the right
{
    x = sectionRight-6;
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher) dir = "right";
}
else if newSectionXOffset &lt; 0 //Switching to the left
{
    x = sectionLeft+6;
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher) dir = "left";
}
else if newSectionYOffset &gt; 0 //Switching down
{
    y  = sectionBottom-6 + sprite_yoffset - (sprite_height/2);
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher) dir = "down";
}
else if newSectionYOffset &lt; 0 //Switching up
{
    y  = sectionTop+6 + sprite_yoffset - (sprite_height/2);
    playerCameraInit();
    with instance_create(x, y, objSectionSwitcher) dir = "up";
}

//If there was a moving platform below Mega Man, adjust it to remain below him
if ground == true &amp;&amp; plt &gt;= 0 &amp;&amp; plt.keepOnSwitch {
    plt.y = bbox_bottom + plt.sprite_yoffset + 1;
}
if (instance_exists(objSectionSwitcher) &amp;&amp; plt &gt; -1 &amp;&amp; plt.keepOnSwitch) {
    objSectionSwitcher.plt = plt;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Executed 1 frame after the Create event
canStep = true;
playerDeactivateObjects(); //Do not do this on frame 1, as it can prevent some Create events from executing
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.frozen == false
{
    //Shooting (before sprite handling to update the sprites properly)
    playerShoot();
    
    //Handle the sprites
    playerHandleSprites();
    
    //General step event code
    playerStep();
    
    //Collision code
    playerCollision();
    
    //Handles moving platform collision
    playerMovingPlatform();
    
    //Pausing
    playerPause();
    
    //Camera
    playerCamera();
    
    //Moving from one section to the next, if possible
    playerSwitchSections();
    
    //Quick weapon switching
    playerSwitchWeapons();

}
else
{
    image_speed = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reflection
if other.reflectible {
    with other {
        var ID = instance_create(x, y, objReflectedProjectile);
        ID.sprite_index = sprite_index;
        ID.image_index = 0;
        ID.image_speed = 0;
        ID.image_xscale = image_xscale;
        ID.dir = sign(xspeed);
            
        instance_destroy();
    }
    
    playSFX(sfxReflect);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change colors depending on the special weapon
//Primary is the helmet color (dark blue), secondary is the shirt color (cyan)
global.primaryCol = weapons[global.weapon].primaryCol;
global.secondaryCol = weapons[global.weapon].secondaryCol;

global.outlineCol = c_black;

if canStep {  //global.keyPausePressed was unknown at the first frame because of event order
    if !global.keyPausePressed {  //The pause menu also resets the colors as to not show charging colors in the Mega Man sprite at the bottom right
                                        //However, we do not want to reset the charge after pausing
        chargeTimer = 0;
        initChargeTimer = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Create necessary objects
if !instance_exists(objGlobalControl)
    instance_create(x, y, objGlobalControl);
    
if !instance_exists(objHealthWeaponBar)
    instance_create(x, y, objHealthWeaponBar);
    
if !instance_exists(objFadeIn)
    instance_create(x, y, objFadeIn);
    
//map_surf = drawMap(room, 1/48, x, y);

playerCameraInit();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if teleporting == false &amp;&amp; showReady == false
{
    //Draws the player. Whitemasks will be used
    drawPlayer();
    
    //Hitspark
    if drawHitspark == true
    {
        draw_sprite_ext(sprHitspark, 0, sprite_get_xcenter(), sprite_get_ycenter(), image_xscale, image_yscale, 0, c_white, 1);
    }
    
    //Weapon icon (when using quick weapon switching)
    if drawWeaponIcon == true
    {
        if climbing == false
            draw_sprite_ext(sprWeaponIconsColor, global.weapons[global.weapon].ID, round(x-8) + image_xscale, round(y-30), 1, 1, 0, c_white, 1);
        else
            draw_sprite_ext(sprWeaponIconsColor, global.weapons[global.weapon].ID, round(x-8), round(y-30), 1, 1, 0, c_white, 1);
    }
}
else if teleporting == true
{   
    if round(view_yview[0]-32+teleportY) &gt;= y
    {
        if teleportTimer == 0
            playSFX(sfxTeleportIn);
        
        //Done teleporting; play a little animation before giving Mega Man control
        if teleportTimer != 9   //MM disappears for one frame in MM6
            drawPlayer();
        
        if teleportTimer == 2
            image_index = 1;
        else if teleportTimer == 4
            image_index = 0;
        else if teleportTimer == 6
            image_index = 2;
        else if teleportTimer = 9
        {
            teleporting = false;
            teleportTimer = 0;
            canSpriteChange = true;
            canMove = true;
            teleportY = 0;
            canGravity = true;
            canPause = true;
            sprite_index = spriteStand;
            instance_activate_all();
            exit;
        }
        
        teleportTimer += 1;
    }
    else
    {
        //Teleporting downwards
        image_index = 0;
        drawSpriteColorSwap(spriteTeleport, image_index, round(x), round(view_yview[0]-32+teleportY), primary_color, secondary_color, make_colour_rgb(1.0, 1.0, 1.0),global.primaryCol,global.secondaryCol, global.outlineCol);
        teleportY += 7;
    }
}
else if showReady == true
{
    //Draw the READY text
    readyTimer += 1;
    
    var readyIndicator;
    readyIndicator = readyTimer mod 12;
    if readyIndicator &gt;= 6 &amp;&amp; readyIndicator &lt;= 11 //For the last 7 frames of every 14 frames, show the READY text
        draw_sprite_ext(sprReady, 0, round(view_xview[0]+(view_wview[0]/2)), round(view_yview[0]+(view_hview[0]/2)), 1, 1, 0, c_white, 1);
        
    if readyTimer &gt;= 72
    {
        readyTimer = 0;
        showReady = false;
        
        //Teleporting sequence
        teleporting = true;
        teleportY = 0;
        teleportTimer = 0;
        sprite_index = spriteTeleport;
        image_speed = 0;
        image_index = 0;
    }
}

if debug_mode || cfgDebug {
    draw_set_color(c_white);
    draw_rectangle(bbox_left,bbox_top,bbox_right,bbox_bottom,1);
    draw_arrow(sprite_get_xcenter(), sprite_get_ycenter(), sprite_get_xcenter() + global.xspeed * 10, sprite_get_ycenter() + global.yspeed * 10, 10);
}

/*if keyboard_check(ord('M')) {
    draw_surface(map_surf, view_xview[0], view_yview[0]);
}*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>10,7</point>
    <point>12,12</point>
  </PhysicsShapePoints>
</object>
